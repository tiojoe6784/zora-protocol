<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minter</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/remixicon@3.5.0/fonts/remixicon.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@web3modal/ethereum@2.7.1/dist/index.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@walletconnect/web3-provider@1.8.0/dist/umd/index.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.10.0/dist/web3.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@uniswap/sdk-core"></script>
    <script src="https://cdn.jsdelivr.net/npm/@uniswap/v3-sdk"></script>
    <script src="https://unpkg.com/@zoralabs/protocol-deployments"></script>
    <script src="https://unpkg.com/@zoralabs/coins-sdk"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', sans-serif;
        }

        /* Sidebar Styles */
        .sidebar {
            position: fixed;
            left: 0;
            top: 0;
            height: 100vh;
            width: 250px;
            background: #111111;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            transform: translateX(-250px);
            transition: transform 0.3s ease;
            z-index: 1001;
            padding-top: 70px;
        }

        .sidebar.active {
            transform: translateX(0);
        }

        .sidebar-toggle {
            position: fixed;
            left: 20px;
            top: 20px;
            z-index: 1002;
            background: none;
            border: none;
            color: #00FF00;
            font-size: 24px;
            cursor: pointer;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .sidebar-toggle:hover {
            background: rgba(0, 255, 0, 0.1);
        }

        .sidebar-menu {
            list-style: none;
            padding: 20px 0;
        }

        .sidebar-menu li {
            padding: 0;
            margin: 4px 0;
        }

        .sidebar-menu a {
            display: flex;
            align-items: center;
            padding: 12px 24px;
            color: rgba(255, 255, 255, 0.7);
            text-decoration: none;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            border-left: 3px solid transparent;
        }

        .sidebar-menu a:hover {
            background: rgba(0, 255, 0, 0.05);
            color: #00FF00;
            border-left-color: #00FF00;
        }

        .sidebar-menu a.active {
            background: rgba(0, 255, 0, 0.1);
            color: #00FF00;
            border-left-color: #00FF00;
        }

        .sidebar-menu i {
            margin-right: 12px;
            font-size: 18px;
            width: 20px;
            text-align: center;
        }

        body {
            background: #000000;
            color: #ffffff;
            line-height: 1.6;
            padding-top: 70px; /* Space for fixed header */
            transition: margin-left 0.3s ease;
        }

        body.sidebar-open {
            margin-left: 250px;
        }
        
        .nav-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #000000;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1000;
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .nav-header .logo {
            display: flex;
            align-items: center;
            gap: 1rem;
            text-decoration: none;
            color: #ffffff;
        }

        .nav-header .logo img {
            height: 32px;
            width: auto;
        }

        .nav-header .logo span {
            font-weight: 600;
            font-size: 1.2rem;
        }

        .nav-links {
            display: flex;
            gap: 2rem;
            align-items: center;
        }

        .nav-links a {
            text-decoration: none;
            color: rgba(255, 255, 255, 0.7);
            font-weight: 500;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-size: 0.9rem;
        }

        .nav-links a:hover {
            color: #00FF00;
        }

        #nav-wallet-connect {
            margin-left: 24px;
        }

        #nav-wallet-connect button {
            background: rgba(0, 255, 0, 0.1);
            color: #00FF00;
            border: 1px solid #00FF00;
            padding: 8px 20px;
            border-radius: 8px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        #nav-wallet-connect button:hover {
            background: #00FF00;
            color: #000000;
            transform: translateY(-1px);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }

        .container {
            max-width: 600px;
            margin: 40px auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin: 20px 0 40px;
            padding: 60px 0;
            background: linear-gradient(165deg, rgba(0, 255, 0, 0.05) 0%, rgba(0, 255, 0, 0.02) 100%);
            border-radius: 16px;
            border: 1px solid rgba(0, 255, 0, 0.1);
        }

        .header h1 {
            font-size: 3.5em;
            font-weight: 700;
            margin-bottom: 20px;
            color: #00FF00;
            text-transform: uppercase;
            letter-spacing: -0.02em;
            line-height: 1.2;
        }

        .header p {
            color: rgba(255, 255, 255, 0.7);
            font-size: 1.2em;
            max-width: 600px;
            margin: 0 auto;
            line-height: 1.6;
        }

        .card {
            background: #111111;
            border-radius: 16px;
            padding: 30px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .form-group {
            margin-bottom: 24px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #ffffff;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .form-group input {
            width: 100%;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            font-size: 16px;
            color: #ffffff;
            transition: all 0.3s ease;
        }

        .form-group input:focus {
            outline: none;
            border-color: #00FF00;
            background: rgba(255, 255, 255, 0.1);
        }

        .form-group input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .radio-group {
            display: flex;
            gap: 1rem;
            margin-top: 0.5rem;
        }

        .radio-group label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
        }

        .radio-group input[type="radio"] {
            width: auto;
            margin: 0;
        }

        .help-text {
            font-size: 0.85em;
            color: rgba(255, 255, 255, 0.5);
            margin-top: 8px;
            font-style: italic;
        }

        .connect-button, .submit-button {
            width: 100%;
            padding: 14px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .connect-button {
            background: rgba(0, 255, 0, 0.1);
            color: #00FF00;
            margin-bottom: 20px;
            border: 1px solid #00FF00;
        }

        .connect-button:hover {
            background: #00FF00;
            color: #000000;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }

        .submit-button {
            background: #00FF00;
            color: #000000;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-weight: 600;
        }

        .connect-button:hover, .submit-button:hover {
            transform: translateY(-2px);
            background: #00FF00;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }

        .status {
            margin-top: 24px;
            padding: 16px;
            border-radius: 8px;
            text-align: center;
        }

        .status.loading {
            background: #f0f0f0;
            color: #666;
        }

        .status.success {
            background: #e6ffe6;
            color: #008000;
        }

        .status.error {
            background: #ffe6e6;
            color: #ff0000;
        }

        .wallet-status {
            text-align: center;
            margin-bottom: 20px;
            font-size: 0.9em;
            color: #666;
        }

        .wallet-connected {
            color: #008000;
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #FF3366;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        .preview-section {
            margin-top: 24px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            display: none;
        }

        .preview-section.active {
            display: block;
        }

        .preview-section h3 {
            margin-bottom: 16px;
            color: #333;
        }

        .preview-image {
            width: 120px;
            height: 120px;
            border-radius: 8px;
            object-fit: cover;
            margin-bottom: 16px;
        }

        .preview-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 16px;
            margin-top: 16px;
        }

        .preview-item {
            background: white;
            padding: 12px;
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .preview-item strong {
            display: block;
            font-size: 0.9em;
            color: #666;
            margin-bottom: 4px;
        }

        .preview-item span {
            font-size: 1em;
            color: #333;
        }

        .action-buttons {
            display: flex;
            gap: 12px;
            margin-bottom: 24px;
        }

        .secondary-button {
            padding: 8px 16px;
            background: #f0f0f0;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            color: #333;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .secondary-button:hover {
            background: #e0e0e0;
        }

        .json-preview {
            background: #1e1e1e;
            color: #fff;
            padding: 16px;
            border-radius: 8px;
            font-family: monospace;
            white-space: pre-wrap;
            margin-top: 16px;
            display: none;
        }

        .json-preview.active {
            display: block;
        }

        /* Tab Styles */
        .tabs {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            padding: 0 1rem;
        }

        .tab-button {
            padding: 0.75rem 1.5rem;
            border: none;
            background: none;
            font-size: 0.9rem;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .tab-button:hover {
            color: #00FF00;
        }

        .tab-button.active {
            color: #00FF00;
            border-bottom-color: #00FF00;
        }

        .tab-container {
            position: relative;
            min-height: 400px;
        }

        .tab-content {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .tab-content.active {
            position: relative;
            visibility: visible;
            opacity: 1;
        }

        /* Trading Interface Styles */
        .trading-container {
            padding: 1.5rem;
        }

        .token-selector {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1.5rem;
            padding: 1rem;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .token-selector input {
            flex: 1;
            padding: 0.75rem;
            border: 1px solid #e1e1e1;
            border-radius: 4px;
            font-size: 1rem;
        }

        .token-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .info-card {
            padding: 1.5rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            transition: all 0.3s ease;
        }

        .info-card:hover {
            transform: translateY(-2px);
            border-color: #00FF00;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.1);
        }

        .info-card h4 {
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 0.5rem;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .info-card p {
            font-size: 1.5rem;
            font-weight: 600;
            color: #00FF00;
            margin: 0;
        }

        .trade-actions {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .trade-input-group {
            position: relative;
            margin-bottom: 1rem;
        }

        .trade-input-group input {
            width: 100%;
            padding: 1rem;
            padding-right: 4rem;
            border: 2px solid #e1e1e1;
            border-radius: 8px;
            font-size: 1.1rem;
        }

        .trade-input-group .max-button {
            position: absolute;
            right: 0.5rem;
            top: 50%;
            transform: translateY(-50%);
            padding: 0.25rem 0.75rem;
            background: #f0f0f0;
            border: none;
            border-radius: 4px;
            font-size: 0.8rem;
            cursor: pointer;
        }

        .trade-actions button {
            width: 100%;
            padding: 1rem;
            border: 1px solid;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            background: transparent;
        }

        .trade-actions .buy-button {
            border-color: #00FF00;
            color: #00FF00;
        }

        .trade-actions .buy-button:hover {
            background: #00FF00;
            color: #000000;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }

        .trade-actions .sell-button {
            border-color: #FF3366;
            color: #FF3366;
        }

        .trade-actions .sell-button:hover {
            background: #FF3366;
            color: #000000;
            box-shadow: 0 0 20px rgba(255, 51, 102, 0.3);
        }

        .price-impact {
            text-align: center;
            margin-top: 1rem;
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .chart-container {
            margin: 2rem 0;
            height: 300px;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }

        .liquidity-form {
            margin-top: 2rem;
            padding: 1.5rem;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .liquidity-form .trade-input-group {
            margin-bottom: 1.5rem;
        }

        .liquidity-form label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: #333;
        }

        .liquidity-form .help-text {
            margin-top: 1rem;
            padding: 1rem;
            background: rgba(255, 51, 102, 0.1);
            border-radius: 8px;
            color: #666;
            font-size: 0.9rem;
            text-align: center;
        }

        .liquidity-form .submit-button {
            margin-bottom: 1rem;
        }

        /* Responsive Styles */
        @media (max-width: 768px) {
            .sidebar {
                width: 280px;
                transform: translateX(-280px);
            }

            body.sidebar-open {
                margin-left: 0;
            }

            .sidebar.active {
                box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            }

            .container {
                padding: 10px;
                margin: 20px auto;
            }

            .header {
                padding: 30px 0;
            }

            .header h1 {
                font-size: 2em;
            }

            .card {
                padding: 20px;
            }

            .nav-header {
                padding: 1rem;
            }

            .nav-links a {
                display: none;
            }

            #nav-wallet-connect {
                margin-left: 0;
            }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <button class="sidebar-toggle" id="sidebarToggle">
        <i class="ri-menu-line"></i>
    </button>

    <nav class="sidebar" id="sidebar">
        <ul class="sidebar-menu">
            <li><a href="#" class="active" data-section="create"><i class="ri-add-circle-line"></i> Create Coin</a></li>
            <li><a href="#" data-section="trade"><i class="ri-exchange-line"></i> Trade</a></li>
            <li><a href="#" data-section="liquidity"><i class="ri-water-flash-line"></i> Liquidity</a></li>
            <li><a href="#" data-section="portfolio"><i class="ri-pie-chart-line"></i> Portfolio</a></li>
            <li><a href="#" data-section="rewards"><i class="ri-gift-line"></i> Rewards</a></li>
            <li><a href="https://docs.zora.co" target="_blank"><i class="ri-book-open-line"></i> Documentation</a></li>
            <li><a href="https://zora.co" target="_blank"><i class="ri-compass-3-line"></i> Explorer</a></li>
        </ul>
    </nav>

    <nav class="nav-header">
        <a href="/" class="logo">
            <img src="https://zora.co/assets/zora-wordmark-white.svg" alt="Zora Logo">
        </a>
        <div class="nav-links">
            <div id="nav-wallet-connect"></div>
        </div>
    </nav>

    <div class="container">
        <div class="header">
            <h1>Zora Creator Coin Platform</h1>
            <p>Create, trade, and manage creator tokens on the Zora Protocol</p>
        </div>

        <div class="tabs">
            <button class="tab-button active" data-tab="create">Create Coin</button>
            <button class="tab-button" data-tab="trade">Trade</button>
            <button class="tab-button" data-tab="liquidity">Liquidity</button>
        </div>

        <div class="tab-container">
            <div class="card tab-content active" id="create-tab">
            <div id="rainbowkit-wrapper">
                <!-- RainbowKit Connect Button will be mounted here -->
            </div>

            <form id="createCoinForm">
                <div class="form-group">
                    <label>Coin Type</label>
                    <div class="radio-group">
                        <label>
                            <input type="radio" name="coinType" value="CREATOR" checked>
                            Creator Coin
                        </label>
                        <label>
                            <input type="radio" name="coinType" value="CONTENT">
                            Content Coin
                        </label>
                    </div>
                    <div class="help-text" id="coinTypeHelp">Creator coins represent your brand, while content coins represent individual posts</div>
                </div>

                <div class="form-group" id="contentCoinFields" style="display: none;">
                    <label for="creatorCoin">Creator Coin Address</label>
                    <input type="text" id="creatorCoin" placeholder="0x...">
                    <div class="help-text">The creator coin that backs this content coin</div>
                </div>

                <div class="form-group">
                    <label for="name">Coin Name</label>
                    <input type="text" id="name" required placeholder="e.g., Artist Coin">
                    <div class="help-text">Choose a memorable name for your coin</div>
                </div>

                <div class="form-group">
                    <label for="symbol">Symbol</label>
                    <input type="text" id="symbol" required placeholder="e.g., ARTC" maxlength="5">
                    <div class="help-text">A short identifier for your coin (max 5 characters)</div>
                </div>

                <div class="form-group">
                    <label for="metadata">Metadata URI</label>
                    <div class="action-buttons">
                        <button type="button" class="secondary-button" id="generateMetadata">Generate Sample Metadata</button>
                        <button type="button" class="secondary-button" id="previewMetadata">Preview Metadata</button>
                    </div>
                    <input type="url" id="metadata" required placeholder="https://...">
                    <div class="help-text">URL to your coin's JSON metadata file</div>
                </div>

                <div id="metadataPreview" class="preview-section">
                    <h3>Metadata Preview</h3>
                    <img id="previewImage" class="preview-image" src="" alt="Coin Image">
                    <div class="preview-grid">
                        <div class="preview-item">
                            <strong>Name</strong>
                            <span id="previewName"></span>
                        </div>
                        <div class="preview-item">
                            <strong>Symbol</strong>
                            <span id="previewSymbol"></span>
                        </div>
                        <div class="preview-item">
                            <strong>Category</strong>
                            <span id="previewCategory"></span>
                        </div>
                        <div class="preview-item">
                            <strong>Platform</strong>
                            <span id="previewPlatform"></span>
                        </div>
                    </div>
                    <pre id="jsonPreview" class="json-preview"></pre>
                </div>

                <button type="submit" class="submit-button" disabled>
                    Create Coin
                </button>
            </form>

            <div id="result" class="status"></div>
        </div>

        <div class="card tab-content" id="trade-tab">
            <div class="trading-container">
                <div class="token-selector">
                    <input type="text" placeholder="Search creator coin by name or address" id="tokenSearch">
                    <button class="secondary-button" id="searchToken">Search</button>
                </div>

        <div class="token-info">
            <div class="info-card">
                <h4>Current Price</h4>
                <p id="currentPrice">-</p>
            </div>
            <div class="info-card">
                <h4>24h Volume</h4>
                <p id="volume24h">-</p>
            </div>
            <div class="info-card">
                <h4>Market Cap</h4>
                <p id="marketCap">-</p>
            </div>
            <div class="info-card">
                <h4>Total Supply</h4>
                <p id="totalSupply">-</p>
            </div>
            <div class="info-card">
                <h4>Vested Amount</h4>
                <p id="vestedAmount">-</p>
                <button class="secondary-button" id="claimVesting" disabled>Claim Vested Tokens</button>
            </div>
            <div class="info-card">
                <h4>ZORA Rewards</h4>
                <p id="zoraRewards">-</p>
                <button class="secondary-button" id="claimRewards" disabled>Claim ZORA Rewards</button>
            </div>
        </div>                <div class="chart-container">
                    <div id="priceChart">Price chart will be displayed here</div>
                </div>

                <div class="trade-actions">
                    <div class="trade-input-group">
                        <input type="number" id="tradeAmount" placeholder="Amount">
                        <button class="max-button" id="maxButton">MAX</button>
                    </div>
                    
                    <button class="buy-button" id="buyButton" disabled>Buy</button>
                    <button class="sell-button" id="sellButton" disabled>Sell</button>

                    <div class="price-impact" id="priceImpact"></div>
                </div>
            </div>
        </div>

        <div class="card tab-content" id="liquidity-tab">
            <div class="trading-container">
                <div class="token-selector">
                    <input type="text" placeholder="Search creator coin by name or address" id="lpTokenSearch">
                    <button class="secondary-button" id="lpSearchToken">Search</button>
                </div>

                <div class="token-info">
                    <div class="info-card">
                        <h4>Pool Total Value Locked</h4>
                        <p id="poolTVL">-</p>
                    </div>
                    <div class="info-card">
                        <h4>Your Pool Share</h4>
                        <p id="poolShare">-</p>
                    </div>
                    <div class="info-card">
                        <h4>Pool Token Balance</h4>
                        <p id="poolTokenBalance">-</p>
                    </div>
                    <div class="info-card">
                        <h4>Pool ETH Balance</h4>
                        <p id="poolEthBalance">-</p>
                    </div>
                </div>

                <div class="liquidity-form">
                    <div class="trade-input-group">
                        <label for="tokenAmount">Token Amount</label>
                        <input type="number" id="tokenAmount" placeholder="Enter token amount">
                        <button class="max-button" id="tokenMaxButton">MAX</button>
                    </div>

                    <div class="trade-input-group">
                        <label for="ethAmount">ETH Amount</label>
                        <input type="number" id="ethAmount" placeholder="Enter ETH amount">
                        <button class="max-button" id="ethMaxButton">MAX</button>
                    </div>
                    
                    <button class="submit-button" id="addLiquidityButton" disabled>Add Liquidity</button>
                    <button class="secondary-button" id="removeLiquidityButton" disabled>Remove Liquidity</button>

                    <div class="help-text" id="liquidityInfo">
                        Adding liquidity will give you pool tokens representing your share of the pool. 
                        You can redeem these tokens later to withdraw your liquidity.
                    </div>
                </div>
            </div>
        </div>
        </div>
    </div>

    <script>
        // Initialize Web3Modal
        const web3modalConfig = {
            projectId: '8b2d0dd39c1cced02ecce163a96a8cb5',
            theme: 'dark',
            accentColor: 'default',
            ethereum: {
                appName: 'Zora Creator Coin Minter',
                chains: [{
                    id: 84532,
                    name: 'Base Sepolia',
                    network: 'base-sepolia',
                    rpcUrls: {
                        default: 'https://sepolia.base.org'
                    },
                    nativeCurrency: {
                        name: 'ETH',
                        symbol: 'ETH',
                        decimals: 18
                    },
                    blockExplorerUrls: ['https://sepolia.basescan.org']
                }]
            }
        };

        // Initialize Web3Modal
        const web3Modal = new window.Web3Modal.default(web3modalConfig);
        let web3, selectedAccount;
        const baseSepolia = {
            id: 84532,
            name: 'Base Sepolia',
            network: 'base-sepolia',
            nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
            rpcUrls: {
                default: { http: ['https://sepolia.base.org'] },
                public: { http: ['https://sepolia.base.org'] }
            },
            testnet: true
        };

        const { publicProvider } = window.wagmi.providers;

        const { chains, publicClient, webSocketPublicClient } = configureChains(
            [baseSepolia],
            [publicProvider()]
        );

        const config = createConfig({
            autoConnect: true,
            publicClient,
            webSocketPublicClient,
            connectors: [
                ...window.wagmi.connectors.baseConnectors({ 
                    chains,
                    projectId,
                    appName: 'Zora Creator Coin Minter',
                })
            ]
        });

        // Initialize RainbowKit
        const { ConnectButton } = window.rainbowkit;

        // Create RainbowKit provider
        const appInfo = {
            appName: 'Zora Creator Coin Minter'
        };

        // Create connect wallet buttons
        const navConnectButton = document.createElement('button');
        navConnectButton.className = 'connect-button';
        navConnectButton.textContent = 'Connect Wallet';
        navConnectButton.style.margin = '0';
        navConnectButton.style.padding = '8px 16px';
        navConnectButton.style.background = '#FF3366';
        
        const formConnectButton = document.createElement('button');
        formConnectButton.className = 'connect-button';
        formConnectButton.textContent = 'Connect Wallet';

        // Connect wallet function
        async function connectWallet() {
            try {
                const provider = await web3Modal.connect();
                web3 = new Web3(provider);
                
                const accounts = await web3.eth.getAccounts();
                selectedAccount = accounts[0];
                
                const shortenedAddress = `${selectedAccount.slice(0, 6)}...${selectedAccount.slice(-4)}`;
                navConnectButton.textContent = shortenedAddress;
                formConnectButton.style.display = 'none';
                submitButton.disabled = false;

                // Subscribe to account changes
                provider.on('accountsChanged', async (accounts) => {
                    selectedAccount = accounts[0];
                    const shortenedAddress = `${selectedAccount.slice(0, 6)}...${selectedAccount.slice(-4)}`;
                    navConnectButton.textContent = shortenedAddress;
                });

                return selectedAccount;
            } catch (error) {
                console.error('Failed to connect wallet:', error);
            }
        }

        // Add click handlers
        navConnectButton.onclick = connectWallet;
        formConnectButton.onclick = connectWallet;

        // Mount the buttons
        document.getElementById('nav-wallet-connect').appendChild(navConnectButton);
        document.getElementById('rainbowkit-wrapper').appendChild(formConnectButton);

        // Form handling
        const form = document.getElementById('createCoinForm');
        const submitButton = document.querySelector('.submit-button');
        const resultDiv = document.getElementById('result');
        const generateMetadataBtn = document.getElementById('generateMetadata');
        const previewMetadataBtn = document.getElementById('previewMetadata');
        const coinTypeRadios = document.querySelectorAll('input[name="coinType"]');
        const contentCoinFields = document.getElementById('contentCoinFields');
        const coinTypeHelp = document.getElementById('coinTypeHelp');

        // Handle coin type toggle
        coinTypeRadios.forEach(radio => {
            radio.addEventListener('change', (e) => {
                const isContent = e.target.value === 'CONTENT';
                contentCoinFields.style.display = isContent ? 'block' : 'none';
                coinTypeHelp.textContent = isContent 
                    ? 'Content coins are backed by creator coins and represent individual posts'
                    : 'Creator coins represent your brand and vest over 5 years';
                
                // Update form validation
                document.getElementById('creatorCoin').required = isContent;
            });
        });
        const metadataPreview = document.getElementById('metadataPreview');
        const jsonPreview = document.getElementById('jsonPreview');
        const metadataInput = document.getElementById('metadata');
        
        const sampleMetadata = {
            name: "Sample Creator Coin",
            symbol: "SAMPLE",
            description: "This is a sample creator coin on the Zora Protocol",
            image: "https://i.imgur.com/ZfJKxpH.png",
            external_url: "https://zora.co",
            attributes: [
                {
                    trait_type: "Category",
                    value: "Creator Token"
                },
                {
                    trait_type: "Platform",
                    value: "Zora"
                },
                {
                    trait_type: "Network",
                    value: "Base Sepolia"
                }
            ]
        };

        async function createCoin(params) {
            resultDiv.className = 'status loading';
            resultDiv.innerHTML = '<div class="loading-spinner"></div> Creating your coin...';
            
            try {
                const { createCoin } = window.ZoraCoinsSdk;

                if (!selectedAccount) {
                    throw new Error('Please connect your wallet first');
                }

                const coinType = document.querySelector('input[name="coinType"]:checked').value;
                const isContent = coinType === 'CONTENT';

                const createParams = {
                    call: {
                        creator: selectedAccount,
                        name: params.name,
                        symbol: params.symbol,
                        metadata: {
                            type: "RAW_URI",
                            uri: params.metadata
                        },
                        tokenType: coinType,
                        initialSupply: "1000000000000000000000000000", // 1 billion tokens
                        tradingFeeBips: 30, // 0.3% trading fee
                        creatorRewardBips: 1000, // 10% of fees to creator
                        protocolRewardBips: 1000, // 10% of fees to protocol
                        liquidityLockBips: 3300, // 33% of fees locked as liquidity
                        chainId: 84532
                    },
                    provider: web3.currentProvider,
                    options: {
                        from: selectedAccount
                    }
                };

                if (isContent) {
                    const creatorCoinAddress = document.getElementById('creatorCoin').value;
                    if (!web3.utils.isAddress(creatorCoinAddress)) {
                        throw new Error('Please enter a valid creator coin address');
                    }
                    createParams.call.creatorCoin = creatorCoinAddress;
                    createParams.call.creatorAllocation = "10000000000000000000000000"; // 10M tokens to creator
                } else {
                    createParams.call.creatorAllocation = "500000000000000000000000000"; // 50% to creator
                    createParams.call.vestingPeriod = 157680000; // 5 years in seconds
                }

                const result = await createCoin(createParams);

                resultDiv.className = 'status success';
                resultDiv.innerHTML = `
                    <strong>ðŸŽ‰ Success!</strong><br>
                    Your coin has been created at: <br>
                    <a href="https://sepolia.basescan.org/address/${result.address}" target="_blank">
                        ${result.address}
                    </a>
                `;
            } catch (error) {
                resultDiv.className = 'status error';
                resultDiv.textContent = `Error: ${error.message}`;
            }
        }

        form.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            await createCoin({
                name: document.getElementById('name').value,
                symbol: document.getElementById('symbol').value.toUpperCase(),
                metadata: document.getElementById('metadata').value
            });
        });

        // Metadata preview functionality
        async function previewMetadata(url) {
            try {
                metadataPreview.classList.add('active');
                const response = await fetch(url);
                const metadata = await response.json();
                
                // Update preview elements
                document.getElementById('previewImage').src = metadata.image;
                document.getElementById('previewName').textContent = metadata.name;
                document.getElementById('previewSymbol').textContent = metadata.symbol;
                
                const category = metadata.attributes?.find(attr => attr.trait_type === 'Category')?.value || 'N/A';
                const platform = metadata.attributes?.find(attr => attr.trait_type === 'Platform')?.value || 'N/A';
                
                document.getElementById('previewCategory').textContent = category;
                document.getElementById('previewPlatform').textContent = platform;
                
                // Show formatted JSON
                jsonPreview.textContent = JSON.stringify(metadata, null, 2);
                jsonPreview.classList.add('active');
            } catch (error) {
                alert('Failed to load metadata: ' + error.message);
            }
        }

        // Generate and host sample metadata
        async function generateAndHostMetadata() {
            try {
                // Update sample metadata with form values
                const updatedMetadata = {
                    ...sampleMetadata,
                    name: document.getElementById('name').value || sampleMetadata.name,
                    symbol: document.getElementById('symbol').value || sampleMetadata.symbol
                };

                // Use a temporary storage service (for demo purposes)
                const response = await fetch('https://jsonblob.com/api/jsonBlob', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify(updatedMetadata)
                });

                if (!response.ok) throw new Error('Failed to host metadata');

                // Get the URL of the hosted metadata
                const metadataUrl = response.headers.get('Location');
                metadataInput.value = metadataUrl;

                // Preview the metadata
                await previewMetadata(metadataUrl);
            } catch (error) {
                alert('Failed to generate metadata: ' + error.message);
            }
        }

        // Event listeners for metadata buttons
        generateMetadataBtn.addEventListener('click', generateAndHostMetadata);
        previewMetadataBtn.addEventListener('click', async () => {
            const url = metadataInput.value;
            if (!url) {
                alert('Please enter a metadata URI first');
                return;
            }
            await previewMetadata(url);
        });

        // Watch account changes to update submit button state
        watchAccount((account) => {
            submitButton.disabled = !account.address;
        });

        // Metadata preview functionality
        async function previewMetadata(url) {
            try {
                metadataPreview.classList.add('active');
                const response = await fetch(url);
                const metadata = await response.json();
                
                // Update preview elements
                document.getElementById('previewImage').src = metadata.image;
                document.getElementById('previewName').textContent = metadata.name;
                document.getElementById('previewSymbol').textContent = metadata.symbol;
                
                const category = metadata.attributes?.find(attr => attr.trait_type === 'Category')?.value || 'N/A';
                const platform = metadata.attributes?.find(attr => attr.trait_type === 'Platform')?.value || 'N/A';
                
                document.getElementById('previewCategory').textContent = category;
                document.getElementById('previewPlatform').textContent = platform;
                
                // Show formatted JSON
                jsonPreview.textContent = JSON.stringify(metadata, null, 2);
                jsonPreview.classList.add('active');
            } catch (error) {
                alert('Failed to load metadata: ' + error.message);
            }
        }

        // Generate and host sample metadata
        async function generateAndHostMetadata() {
            try {
                // Update sample metadata with form values
                const updatedMetadata = {
                    ...sampleMetadata,
                    name: document.getElementById('name').value || sampleMetadata.name,
                    symbol: document.getElementById('symbol').value || sampleMetadata.symbol
                };

                // Use a temporary storage service (for demo purposes)
                const response = await fetch('https://jsonblob.com/api/jsonBlob', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify(updatedMetadata)
                });

                if (!response.ok) throw new Error('Failed to host metadata');

                // Get the URL of the hosted metadata
                const metadataUrl = response.headers.get('Location');
                metadataInput.value = metadataUrl;

                // Preview the metadata
                await previewMetadata(metadataUrl);
            } catch (error) {
                alert('Failed to generate metadata: ' + error.message);
            }
        }

        // Event listeners for metadata buttons
        generateMetadataBtn.addEventListener('click', generateAndHostMetadata);
        previewMetadataBtn.addEventListener('click', async () => {
            const url = metadataInput.value;
            if (!url) {
                alert('Please enter a metadata URI first');
                return;
            }
            await previewMetadata(url);
        });

        // Sidebar functionality
        function initializeSidebar() {
            const sidebarToggle = document.getElementById('sidebarToggle');
            const sidebar = document.getElementById('sidebar');
            const body = document.body;
            const sidebarLinks = document.querySelectorAll('.sidebar-menu a[data-section]');

            // Toggle sidebar
            sidebarToggle.addEventListener('click', () => {
                sidebar.classList.toggle('active');
                body.classList.toggle('sidebar-open');
                sidebarToggle.innerHTML = sidebar.classList.contains('active') 
                    ? '<i class="ri-close-line"></i>' 
                    : '<i class="ri-menu-line"></i>';
            });

            // Handle sidebar link clicks
            sidebarLinks.forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    
                    // Remove active class from all links
                    sidebarLinks.forEach(l => l.classList.remove('active'));
                    
                    // Add active class to clicked link
                    link.classList.add('active');
                    
                    // Show corresponding tab
                    const section = link.getAttribute('data-section');
                    showTab(section);
                    
                    // Close sidebar on mobile
                    if (window.innerWidth <= 768) {
                        sidebar.classList.remove('active');
                        body.classList.remove('sidebar-open');
                        sidebarToggle.innerHTML = '<i class="ri-menu-line"></i>';
                    }
                });
            });

            // Close sidebar when clicking outside
            document.addEventListener('click', (e) => {
                if (!sidebar.contains(e.target) && 
                    !sidebarToggle.contains(e.target) && 
                    sidebar.classList.contains('active')) {
                    sidebar.classList.remove('active');
                    body.classList.remove('sidebar-open');
                    sidebarToggle.innerHTML = '<i class="ri-menu-line"></i>';
                }
            });
        }

        // Initialize all functionality after DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize sidebar
            initializeSidebar();
            
            // Tab switching functionality
            function initializeTabs() {
                const tabs = document.querySelector('.tabs');
                const tabButtons = tabs.querySelectorAll('.tab-button');
                const tabContents = document.querySelectorAll('.tab-content');

                function showTab(tabId) {
                    console.log('Showing tab:', tabId);
                    
                    // Hide all tabs
                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    tabContents.forEach(content => {
                        content.classList.remove('active');
                        content.style.visibility = 'hidden';
                        content.style.opacity = '0';
                    });

                    // Show selected tab
                    const selectedButton = tabs.querySelector(`[data-tab="${tabId}"]`);
                    const selectedContent = document.getElementById(`${tabId}-tab`);

                    if (selectedButton && selectedContent) {
                        selectedButton.classList.add('active');
                        selectedContent.classList.add('active');
                        selectedContent.style.visibility = 'visible';
                        selectedContent.style.opacity = '1';

                        // Handle special tab initialization
                        if (tabId === 'trade' || tabId === 'liquidity') {
                            const searchInput = document.getElementById(
                                tabId === 'trade' ? 'tokenSearch' : 'lpTokenSearch'
                            );
                            if (searchInput && searchInput.value) {
                                if (tabId === 'trade') {
                                    searchToken();
                                } else {
                                    searchPoolInfo();
                                }
                            }
                        }
                    }
                }

                // Add click handlers
                tabButtons.forEach(button => {
                    button.addEventListener('click', (e) => {
                        e.preventDefault();
                        const tabId = button.getAttribute('data-tab');
                        if (tabId) {
                            console.log('Tab button clicked:', tabId);
                            showTab(tabId);
                        }
                    });
                });

                // Show initial tab
                showTab('create');
            }

            // Initialize tabs
            initializeTabs();

            // Trading functionality
            const searchInput = document.getElementById('tokenSearch');
            const searchButton = document.getElementById('searchToken');
            const buyButton = document.getElementById('buyButton');
            const sellButton = document.getElementById('sellButton');
            const maxButton = document.getElementById('maxButton');
            const tradeAmount = document.getElementById('tradeAmount');
            let currentToken = null;
            // Initialize tab switching
            function initializeTabs() {
                const tabButtons = document.querySelectorAll('.tab-button');
                const tabContents = document.querySelectorAll('.tab-content');

                function switchTab(tabId) {
                    // Remove active class from all buttons and contents
                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    tabContents.forEach(content => content.classList.remove('active'));
                    
                    // Add active class to clicked button and corresponding content
                    const button = document.querySelector(`.tab-button[data-tab="${tabId}"]`);
                    const content = document.getElementById(`${tabId}-tab`);
                    
                    if (button && content) {
                        button.classList.add('active');
                        content.classList.add('active');
                        
                        // If switching to trade or liquidity tab, trigger token search if there's a value
                        if (tabId === 'trade' || tabId === 'liquidity') {
                            const searchInput = document.getElementById(tabId === 'trade' ? 'tokenSearch' : 'lpTokenSearch');
                            if (searchInput && searchInput.value) {
                                if (tabId === 'trade') {
                                    searchToken();
                                } else {
                                    searchPoolInfo();
                                }
                            }
                        }
                    }
                }

                // Add click handlers to all tab buttons
                tabButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        const tabId = button.getAttribute('data-tab');
                        if (tabId) {
                            console.log('Switching to tab:', tabId); // Debug log
                            switchTab(tabId);
                        }
                    });
                });

                // Initialize first tab
                switchTab('create');
            }

            // Initialize tabs
            initializeTabs();
        });

        // Search token
        async function searchToken() {
            const query = searchInput.value;
            if (!query) return;

            try {
                // First try to resolve as an address
                let tokenAddress = query;
                if (!web3.utils.isAddress(query)) {
                    // If not an address, search by name/symbol in the factory
                    const factoryContract = new web3.eth.Contract(
                        [{"inputs":[{"internalType":"string","name":"name","type":"string"}],"name":"getTokenByName","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"}],
                        "0xaF88840cb637F2684A9E460316b1678AD6245e4a" // Factory address
                    );
                    tokenAddress = await factoryContract.methods.getTokenByName(query).call();
                }

                // Get token contract
                const tokenContract = new web3.eth.Contract(
                    [
                        {"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},
                        {"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},
                        {"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
                        {"inputs":[],"name":"getTokenData","outputs":[{"components":[{"internalType":"uint256","name":"price","type":"uint256"},{"internalType":"uint256","name":"volume24h","type":"uint256"},{"internalType":"uint256","name":"marketCap","type":"uint256"}],"internalType":"struct TokenData","name":"","type":"tuple"}],"stateMutability":"view","type":"function"}
                    ],
                    tokenAddress
                );

                // Fetch token data
                const [
                    name, 
                    symbol, 
                    totalSupply, 
                    tokenData,
                    vestedAmount,
                    zoraRewards,
                    vestingData
                ] = await Promise.all([
                    tokenContract.methods.name().call(),
                    tokenContract.methods.symbol().call(),
                    tokenContract.methods.totalSupply().call(),
                    tokenContract.methods.getTokenData().call(),
                    tokenContract.methods.getVestedAmount(selectedAccount).call(),
                    tokenContract.methods.getZoraRewards(selectedAccount).call(),
                    tokenContract.methods.getVestingData().call()
                ]);

                currentToken = {
                    address: tokenAddress,
                    name,
                    symbol,
                    price: web3.utils.fromWei(tokenData.price, 'ether'),
                    volume24h: web3.utils.fromWei(tokenData.volume24h, 'ether'),
                    marketCap: web3.utils.fromWei(tokenData.marketCap, 'ether'),
                    totalSupply: web3.utils.fromWei(totalSupply, 'ether'),
                    contract: tokenContract
                };

                updateTokenInfo(currentToken);
                await loadPriceHistory(tokenAddress);
                enableTrading();
            } catch (error) {
                console.error('Error searching token:', error);
                alert('Failed to fetch token information. Make sure you entered a valid token name or address.');
            }
        }

        function updateTokenInfo(token) {
            document.getElementById('currentPrice').textContent = `${parseFloat(token.price).toFixed(6)} ETH`;
            document.getElementById('volume24h').textContent = `${parseFloat(token.volume24h).toFixed(2)} ETH`;
            document.getElementById('marketCap').textContent = `$${(parseFloat(token.marketCap) * ethPrice).toLocaleString()}`;
            document.getElementById('totalSupply').textContent = parseFloat(token.totalSupply).toLocaleString();
            
            // Update vesting info
            if (token.vestedAmount && token.vestingData) {
                const vestedTokens = web3.utils.fromWei(token.vestedAmount, 'ether');
                const totalVesting = web3.utils.fromWei(token.vestingData.totalAmount, 'ether');
                const vestedPercent = (vestedTokens / totalVesting * 100).toFixed(2);
                document.getElementById('vestedAmount').textContent = 
                    `${parseFloat(vestedTokens).toLocaleString()} (${vestedPercent}%)`;
                document.getElementById('claimVesting').disabled = vestedTokens <= 0;
            }

            // Update ZORA rewards
            if (token.zoraRewards) {
                const rewards = web3.utils.fromWei(token.zoraRewards, 'ether');
                document.getElementById('zoraRewards').textContent = 
                    `${parseFloat(rewards).toLocaleString()} ZORA`;
                document.getElementById('claimRewards').disabled = rewards <= 0;
            }
        }

        async function claimVestedTokens() {
            if (!selectedAccount || !currentToken) return;

            try {
                // Get vested amount first
                const vestedAmount = await currentToken.contract.methods.getVestedAmount(selectedAccount).call();
                if (vestedAmount <= 0) {
                    alert('No tokens available to claim');
                    return;
                }

                // Claim vested tokens
                await currentToken.contract.methods.claimVesting().send({ from: selectedAccount });
                alert('Successfully claimed vested tokens!');
                await searchToken(); // Refresh token info
            } catch (error) {
                console.error('Failed to claim vested tokens:', error);
                alert(`Failed to claim vested tokens: ${error.message}`);
            }
        }

        async function claimZoraRewards() {
            if (!selectedAccount || !currentToken) return;

            try {
                // Get ZORA rewards first
                const rewards = await currentToken.contract.methods.getZoraRewards(selectedAccount).call();
                if (rewards <= 0) {
                    alert('No ZORA rewards available to claim');
                    return;
                }

                // Claim ZORA rewards
                await currentToken.contract.methods.claimZoraRewards().send({ from: selectedAccount });
                alert('Successfully claimed ZORA rewards!');
                await searchToken(); // Refresh token info
            } catch (error) {
                console.error('Failed to claim ZORA rewards:', error);
                alert(`Failed to claim ZORA rewards: ${error.message}`);
            }
        }

        let priceChart;
        async function loadPriceHistory(tokenAddress) {
            try {
                // Get historical events from the Uniswap V4 pool
                const poolContract = new web3.eth.Contract(
                    [{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"token0","type":"address"},{"indexed":true,"internalType":"address","name":"token1","type":"address"},{"indexed":false,"internalType":"uint256","name":"price","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"Swap","type":"event"}],
                    currentToken.poolAddress
                );

                // Get the last 24 hours of swap events
                const events = await poolContract.getPastEvents('Swap', {
                    filter: {
                        token0: tokenAddress,
                        token1: wethAddress
                    },
                    fromBlock: 'latest',
                    toBlock: 'latest'
                });

                // Process events into chart data
                const chartData = events.map(event => ({
                    x: new Date(event.returnValues.timestamp * 1000),
                    y: web3.utils.fromWei(event.returnValues.price, 'ether')
                })).sort((a, b) => a.x - b.x);

                // Create or update chart
                const ctx = document.getElementById('priceChart').getContext('2d');
                if (priceChart) {
                    priceChart.destroy();
                }

                priceChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        datasets: [{
                            label: `${currentToken.symbol}/ETH Price`,
                            data: chartData,
                            borderColor: '#FF3366',
                            backgroundColor: 'rgba(255, 51, 102, 0.1)',
                            fill: true,
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        scales: {
                            x: {
                                type: 'time',
                                time: {
                                    unit: 'hour'
                                }
                            },
                            y: {
                                beginAtZero: false,
                                ticks: {
                                    callback: value => `${value} ETH`
                                }
                            }
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: context => `Price: ${context.parsed.y} ETH`
                                }
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('Error loading price history:', error);
                document.getElementById('priceChart').innerHTML = 'Failed to load price chart';
            }
        }

        function enableTrading() {
            buyButton.disabled = false;
            sellButton.disabled = false;
            maxButton.disabled = false;
        }

        async function calculatePriceImpact(amount) {
            // Mock price impact calculation
            const impact = (amount * 0.001).toFixed(2);
            document.getElementById('priceImpact').textContent = `Price Impact: ${impact}%`;
        }

        async function executeTrade(isBuy) {
            if (!selectedAccount) {
                alert('Please connect your wallet first');
                return;
            }

            const amount = parseFloat(tradeAmount.value);
            if (!amount || amount <= 0) {
                alert('Please enter a valid amount');
                return;
            }

            try {
                const amountIn = web3.utils.toWei(amount.toString(), 'ether');
                
                // Get Uniswap V4 Pool contract
                const poolContract = new web3.eth.Contract(
                    [
                        {"inputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"address","name":"recipient","type":"address"}],"name":"swapExactTokensForETH","outputs":[{"internalType":"uint256","name":"amountOut","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},
                        {"inputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"address","name":"recipient","type":"address"}],"name":"swapExactETHForTokens","outputs":[{"internalType":"uint256","name":"amountOut","type":"uint256"}],"stateMutability":"payable","type":"function"}
                    ],
                    currentToken.poolAddress
                );

                if (isBuy) {
                    // Buy tokens with ETH
                    await poolContract.methods.swapExactETHForTokens(
                        amountIn,
                        selectedAccount
                    ).send({
                        from: selectedAccount,
                        value: amountIn
                    });
                } else {
                    // Approve tokens first if selling
                    await currentToken.contract.methods.approve(
                        currentToken.poolAddress,
                        amountIn
                    ).send({ from: selectedAccount });

                    // Sell tokens for ETH
                    await poolContract.methods.swapExactTokensForETH(
                        amountIn,
                        selectedAccount
                    ).send({ from: selectedAccount });
                }

                // Update token info and chart after trade
                await searchToken();
                
                alert(`Successfully ${isBuy ? 'bought' : 'sold'} ${amount} ${currentToken.symbol}`);
            } catch (error) {
                console.error('Trade failed:', error);
                alert(`Failed to ${isBuy ? 'buy' : 'sell'} tokens: ${error.message}`);
            }
        }

        // Liquidity functions
        async function searchPoolInfo() {
            const query = document.getElementById('lpTokenSearch').value;
            if (!query) return;

            try {
                // Get pool address for the token
                const factoryContract = new web3.eth.Contract(
                    [{"inputs":[{"internalType":"address","name":"token","type":"address"}],"name":"getPool","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"}],
                    "0xaF88840cb637F2684A9E460316b1678AD6245e4a" // Factory address
                );

                let tokenAddress = query;
                if (!web3.utils.isAddress(query)) {
                    // If not an address, search by name/symbol in the factory
                    tokenAddress = await factoryContract.methods.getTokenByName(query).call();
                }

                const poolAddress = await factoryContract.methods.getPool(tokenAddress).call();
                const poolContract = new web3.eth.Contract(
                    [
                        {"inputs":[],"name":"getPoolData","outputs":[{"components":[{"internalType":"uint256","name":"tokenBalance","type":"uint256"},{"internalType":"uint256","name":"ethBalance","type":"uint256"},{"internalType":"uint256","name":"totalSupply","type":"uint256"}],"internalType":"struct PoolData","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},
                        {"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}
                    ],
                    poolAddress
                );

                // Get pool data
                const [poolData, userPoolTokens] = await Promise.all([
                    poolContract.methods.getPoolData().call(),
                    poolContract.methods.balanceOf(selectedAccount).call()
                ]);

                const tvl = web3.utils.fromWei(
                    (poolData.tokenBalance * currentToken.price + poolData.ethBalance).toString(),
                    'ether'
                );
                const share = poolData.totalSupply > 0 
                    ? (userPoolTokens / poolData.totalSupply * 100).toFixed(2) 
                    : '0';

                // Update UI
                document.getElementById('poolTVL').textContent = `$${parseFloat(tvl).toLocaleString()}`;
                document.getElementById('poolShare').textContent = `${share}%`;
                document.getElementById('poolTokenBalance').textContent = 
                    `${web3.utils.fromWei(poolData.tokenBalance, 'ether')} ${currentToken.symbol}`;
                document.getElementById('poolEthBalance').textContent = 
                    `${web3.utils.fromWei(poolData.ethBalance, 'ether')} ETH`;

                // Enable liquidity buttons
                document.getElementById('addLiquidityButton').disabled = false;
                document.getElementById('removeLiquidityButton').disabled = userPoolTokens <= 0;

                return { poolContract, poolAddress, poolData };
            } catch (error) {
                console.error('Error fetching pool info:', error);
                alert('Failed to fetch pool information. Make sure you entered a valid token name or address.');
            }
        }

        async function addLiquidity() {
            if (!selectedAccount || !currentToken) return;

            const tokenAmount = web3.utils.toWei(document.getElementById('tokenAmount').value, 'ether');
            const ethAmount = web3.utils.toWei(document.getElementById('ethAmount').value, 'ether');

            try {
                const pool = await searchPoolInfo();
                if (!pool) return;

                // Approve tokens first
                await currentToken.contract.methods.approve(
                    pool.poolAddress,
                    tokenAmount
                ).send({ from: selectedAccount });

                // Add liquidity
                await pool.poolContract.methods.addLiquidity(
                    tokenAmount,
                    ethAmount,
                    selectedAccount
                ).send({
                    from: selectedAccount,
                    value: ethAmount
                });

                alert('Successfully added liquidity!');
                await searchPoolInfo(); // Refresh pool info
            } catch (error) {
                console.error('Failed to add liquidity:', error);
                alert(`Failed to add liquidity: ${error.message}`);
            }
        }

        async function removeLiquidity() {
            if (!selectedAccount || !currentToken) return;

            try {
                const pool = await searchPoolInfo();
                if (!pool) return;

                const userPoolTokens = await pool.poolContract.methods.balanceOf(selectedAccount).call();
                if (userPoolTokens <= 0) {
                    alert('You don\'t have any liquidity to remove');
                    return;
                }

                // Remove all liquidity
                await pool.poolContract.methods.removeLiquidity(userPoolTokens, selectedAccount)
                    .send({ from: selectedAccount });

                alert('Successfully removed liquidity!');
                await searchPoolInfo(); // Refresh pool info
            } catch (error) {
                console.error('Failed to remove liquidity:', error);
                alert(`Failed to remove liquidity: ${error.message}`);
            }
        }

        // Event listeners for trading
        searchButton.addEventListener('click', searchToken);
        buyButton.addEventListener('click', () => executeTrade(true));
        sellButton.addEventListener('click', () => executeTrade(false));
        maxButton.addEventListener('click', () => {
            // Mock max amount
            tradeAmount.value = '1000';
        });
        tradeAmount.addEventListener('input', () => {
            const amount = parseFloat(tradeAmount.value);
            if (amount > 0) {
                calculatePriceImpact(amount);
            }
        });

        // Liquidity tab event listeners
        document.getElementById('lpSearchToken').addEventListener('click', searchPoolInfo);
        document.getElementById('addLiquidityButton').addEventListener('click', addLiquidity);
        document.getElementById('removeLiquidityButton').addEventListener('click', removeLiquidity);

        document.getElementById('tokenMaxButton').addEventListener('click', async () => {
            if (!selectedAccount || !currentToken) return;
            const balance = await currentToken.contract.methods.balanceOf(selectedAccount).call();
            document.getElementById('tokenAmount').value = web3.utils.fromWei(balance, 'ether');
        });

        document.getElementById('ethMaxButton').addEventListener('click', async () => {
            if (!selectedAccount) return;
            const balance = await web3.eth.getBalance(selectedAccount);
            document.getElementById('ethAmount').value = web3.utils.fromWei(balance, 'ether');
        });

        // Link token search between trade and liquidity tabs
        document.getElementById('lpTokenSearch').addEventListener('input', (e) => {
            document.getElementById('tokenSearch').value = e.target.value;
        });
        document.getElementById('tokenSearch').addEventListener('input', (e) => {
            document.getElementById('lpTokenSearch').value = e.target.value;
        });

        // Add claim button event listeners
        document.getElementById('claimVesting').addEventListener('click', claimVestedTokens);
        document.getElementById('claimRewards').addEventListener('click', claimZoraRewards);
    </script>
</body>
</html>
